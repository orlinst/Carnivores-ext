---
title: "R Notebook"
output: html_notebook
---

#Load up data/tree/imputations
```{r}
require(phytools)
require(mulTree)

tree <- read.nexus("CompletePhyCarn.nex")
data_final <- read.delim("carn-ext.txt", header=T)
rownames(data_final) <- data_final$species_name

data_final$extant <- as.factor(data_final$extant)
data_final$loctype <- as.factor(data_final$loctype)
data_final$diet.cat <- as.factor(data_final$diet.cat)
data_final$activity <- as.factor(data_final$activity)
#data_final$soc.complexity <- as.factor(data_final$soc.complexity)


data_final$afrotropic <- as.factor(data_final$afrotropic)
data_final$australasia <- as.factor(data_final$australasia)
data_final$indomalaya <- as.factor(data_final$indomalaya)
data_final$neotropic <- as.factor(data_final$neotropic)
data_final$nearctic <- as.factor(data_final$nearctic)
data_final$palearctic <- as.factor(data_final$palearctic)


clean <- clean.data(data_final, tree)
tree <- clean$tree
tree1 <- clean$tree[[2]]
data <- clean$data

require(mice)
load("./imp20x100.Rdata")


for(imputedsets in 1: length(imp$imp[[1]])) {
  #extract imputed sets in separate dfs
  assign(paste0("dataX",imputedsets), complete(imp, imputedsets))
}

```


#Function - mi.glm 
```{r}
require(tictoc)
require(phylolm)

mi.glm <- function (multree, sets, model, num, alpha=0.05, btol.v=10, boot.v=0) {
  tic("Total time")
  rand = sample.int(1000, num)
  to = length(rand)
  summaries = list()
  pvals = list()
  estimates = list()
  aic = list()
  a = 0 #counter for sig models
  b = 0
  z = matrix(ncol = (length(colnames(dataX1))*2), nrow =sets*to)
  total = sets*to
  pb <- txtProgressBar(min = 0,      # Minimum value of the progress bar
                       max = total, # Maximum value of the progress bar
                       style = 3,    # Progress bar style (also available style = 1 and style = 2)
                       width = 50,   # Progress bar width. Defaults to getOption("width")
                       char = "=")   # Character used to create the bar
  #z <- NULL
  #z <- data.frame(matrix(ncol = 10, nrow = 10))
  # gets the trees one by one, extracts the coeffs from the summary (as numeric), marks the sig p values 
  # (see print.pval fun) and prints them - progress is displayed
  rand = sample.int(1000, num)
  for (i in rand){
    for (imps in 1:sets){
      temptree <- multree[[i]]
      s1 <- phyloglm(model, get(paste0("dataX", imps)), temptree, method = c("logistic_MPLE"), btol = btol.v, boot=boot.v)
      b = b + 1
      k = summary(s1)$coefficients[,3]
      #print(k)
      #print(length(k))
      z[b, 1 : length(k)] = k
      
      s2 <- as.data.frame(summary(s1)$coefficients[,"p.value"]) #extract p value
      asd <- as.numeric(s2[[1]]) #save it as numeric
      
      s21 <- as.data.frame(summary(s1)$coefficients[,"Estimate"]) #export estimate
      asd1 <- as.numeric(s21[[1]])  #save as numeric
      
      s22 <- as.data.frame(summary(s1)$aic) #export aic
      asd2 <- as.numeric(s22[[1]])
    
      pvals <- rbind(pvals, asd)
      estimates <- rbind(estimates, asd1)
      aic <- rbind(aic, asd2)
      
      #s22 <- as.data.frame(summary(s1)$coefficients)
      summaries[[b]] <- s1

#      
      for(bar in 1:b) {
        setTxtProgressBar(pb, bar)}
      
      
      if(any(asd[-1]<alpha)){
        #print.pval(asd[-1]) 
        a = a+1
        cat("\n", "---------------", "\n", " N Sig models:", a, " out of", b, "", round((a/b)*100, 2), "% " ,"\n", "Models left:", (sets*to)-b, "\n") }
      
      #print(summary(s1)$coefficients[,4])
      print (summary(s1))
      #print(z)
    }
  }
  close(pb)
  cat(paste0("\n ==================== \n", " Total models: ", to, "x", sets, "=", to*sets, " (trees x imputed sets)",  "\n Significant: ", a, "\n ", "p<", alpha," in ", round((a/(to*sets))*100, 2), "% of the tested sets", "\n ==================== \n"))
  zvalues <<- colMeans((z), na.rm=T) # z or abs z?!
  #convert z values to p
  #out <- data.frame()
  
  #cat(paste0("\n P-values \n"))
  vars <- row.names(s2)
  pval <<- 2*pnorm(abs(zvalues[1:length(row.names(s2))]), lower.tail=F)
  out <- data.frame(vars, pval)
  
  #((length(row.names(dataX1)) - (length(row.names(s2)))))
  
  pvals <<- pvals
  colnames(pvals) <<- row.names(s2)
  rownames(pvals) <<- 1:nrow(pvals)
  
  estimates <<- estimates
  colnames(estimates) <<- row.names(s2)
  rownames(estimates) <<- 1:nrow(estimates)
  
  aic <- unlist(aic)
  maic <<- mean(aic)
 
  summaries <<- summaries
  
  print(out)
  print(maic)
  toc()
  out <<- out
}
```


#Function - plot.mi.glm
```{r}
plot.mi.glm <- function (pvals, estimates) {


pvals <- as.data.frame(pvals)
estimates <- as.data.frame(estimates)

pvals <- lapply(pvals, as.numeric)
estimates <- lapply(estimates, as.numeric)

pvals <- as.data.frame(pvals)
estimates <- as.data.frame(estimates)



#PLOT LOOP



for (i in 2:ncol(pvals)) {
  dev.next()
  par(mfrow=c(1,2))
  #breaks=nrow(pvals)
  #breaks=nrow(estimates)
  
  h <- hist(pvals[,i], breaks=50, plot=FALSE)
  cuts <- cut(h$breaks, c(-Inf, 0.05,1))
  plot(h, col=c("firebrick", "white")[cuts], main=paste(colnames(pvals)[i], ": Histogram of p-values \n N =", nrow(pvals), "Trees = ", nrow(pvals)/length(imp$imp[[1]]), "\n ", sum(pvals[,i] <= 0.05), "<=0.05", " \n median =", signif(median(pvals[,i]))), xlab="p-values", xaxt='n', cex.main=0.8)
  text(h$mids,h$counts,labels=h$counts, adj=c(0.5, -0.5),)
  axis(1, at = seq(0, 1, by = 0.01), las=2)
  abline(v=median(pvals[,i]),col="blue",lwd=3)
  arrows(x0 = 0.05,
         y0 = 0.001,
         x1 = 0.05,
         y1 = 100,
         code =1,
         length = 0.1,
         lwd = 4,
         col = "yellow")
  
  
  h1 <- hist(estimates[,i], breaks = 25, main=paste("Histogram of estimates \n N=", nrow(estimates), "median =", signif(median(estimates[,i]))), xlab="Estimates", col="darkmagenta", cex.main=0.8)
  text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
  
}
}
```


#Calls
```{r}
#run in loop

var = as.data.frame(colnames(data_final)) #check variable names
var = var[-c(1,2, 5),1] #remove chars and extant

for (i in var) { model = paste0("extant ~", i) #add var +
                tic("Time")
                invisible(capture.output(mi.glm(tree, 20, model, 20)))
                toc()
                print(out)
                print(maic)
                plot.mi.glm (pvals, estimates)}


mi.glm(tree, 20, extant ~ mass.g, 50)

#OR
tic("Time")
invisible(capture.output(mi.glm(tree, 20, extant ~ mass.g, 2)))
toc()
out
###### mi.glm(tree, 25, extant ~ afrotropic + australasia+indomalaya+nearctic+neotropic+palearctic, 50)

plot.mi.glm (pvals, estimates)

require(mitools)

MIcombine(summaries, df.complete = 110)
summary(MIcombine(summaries))


betas <- MIextract(summaries,fun=coef)
betas1 <- do.call(rbind, betas)
vars <- MIextract(summaries, fun=vcov)
summary(MIcombine(betas,vars))


MIcombineP <- function(MIcombineRes,digits=3) {
  tStat <- MIcombineRes$coefficients/sqrt(diag(MIcombineRes$variance))
  round(2*pt(-abs(tStat),df=MIcombineRes$df),digits)
}

MIcombineP(MIcombine(summaries))


mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic

# (-) BMRres | mass.g | activity | litter | home range | terrestrial
# (+) afrotropic

#eq - n
#social (soc.complexity+gr.size + pc) - n
#reproductive (longevity + ges.days + interbirth.days + weaning.days + litter) - litter (-)
#diet (diet.cat+shannon | simpson) - n
#spatial (home.range + abundance + loctype + afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic) - hr(-), afro(+), locT (-)

```

for (i in 1:25) {colnames(summaries[[i]])[colnames(summaries[[i]]) == 'Estimate'] <- 'estimate'}
sum1 <- as.mira(summaries)





tic()
p = array(dim=32,data=0)
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(extant[b] ~ .,data=dataX1[b,c(3, 4, 6:27)], size = 1)$wts[2:33]
p[w < 0] = p [w < 0] + 1
}
p / 1000
toc()

asd <- nnet(dataX12$extant ~ .,data=dataX12[,c(3,4,6:27)], size = 1) #exclude the extant col



tic()
p = array(dim=114,data=0, dimnames=list(dataX12$species_name))
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(dataX12$extant[b] ~ .,data=dataX12[b,c(3, 4, 6:27)], size = 1)$residuals[,1]
p[names(w)] = p[names(w)]  + w
}
a <- p / 1000
toc()


tic()
p = array(dim=114,data=0, dimnames=list(dataX12$species_name))
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(dataX12$extant[b] ~ .,data=dataX12[b,c(3, 4, 6:27)], size = 1)
w2 = predict(w,dataX12[!1:114 %in% b, c(3, 4, 6:27)] )
p[rownames(w2)] = p[rownames(w2)]  + w2[,1]
}
a <- p / 1000
toc()

sort(a)


aa <- phyloglm(dataX12$extant ~ .,data=dataX12[,c(3,4,6:27)], tree[[12]])

phyloglm(extant ~ .,data=dataX1[, c(3, 4, 6:27)]







#Cross validation - 1
```{r}

var = as.data.frame(colnames(data_final))
var = var[-c(1,2, 5),1]
varX <- paste(var, collapse = "+") #full model


pred.extant <- array(dim = 114, dimnames=list(dataX12$species_name), data = 0)
pred.t <- array(dim= 33, data = 0) #dim is nr of vars
for (i in 1:10) {
  for (imps in 1:length(imp$imp[[1]])) {
  temp.matrix <- complete(imp, imps)
b = sample(1:length(temp.matrix$extant),ceiling(length(temp.matrix$extant) / 2))
#aa1 <- glm(extant ~ home.range + interbirth.days + soc.complexity, temp.matrix[b,], family="binomial")
aa1 <- glm(pnorm(scale(as.numeric(extant))) ~ varX, temp.matrix[b,], family="quasibinomial")
asd <- predict(aa1, newdata=temp.matrix[!1:nrow(data_final) %in% b,])
  if(length(asd) == 0 | is.na(sum(aa1$coefficients)))
  next
  asd = asd[!is.na(asd) & !is.infinite(asd) & !is.nan(asd)]
#exp(asd)/(exp(asd)+1)
pred.extant[names(asd)] = pred.extant[names(asd)] + exp(asd)/(exp(asd)+1)
pred.t = pred.t + summary(aa1)$coefficients[,3]
names(pred.t) = rownames(summary(aa1)$coefficients)
if(is.nan(sum(pred.extant)))
break
  }
}

pred.extant/500 #imps + iters
pred.t/200
names(pred.t) = var


cor.test(pred.extant/200, as.numeric(dataX12$extant), method = "s")


mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic


#FULL MODEL

pred.extant <- array(dim = 114, dimnames=list(dataX12$species_name), data = 0)
pred.t <- array(dim= 33, data = 0) #dim is nr of vars
for (i in 1:10) {
    for (imps in 1:length(imp$imp[[1]])) {
        temp.matrix <- complete(imp, imps)
        b = sample(1:length(temp.matrix$extant),ceiling(length(temp.matrix$extant) / 2))
        #aa1 <- glm(extant ~ home.range + interbirth.days + soc.complexity, temp.matrix[b,], family="binomial")
        aa1 <- glm(pnorm(scale(as.numeric(extant))) ~ mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic, temp.matrix[b,], family="quasibinomial")
        asd <- predict(aa1, newdata=temp.matrix[!1:nrow(data_final) %in% b,])
        if(length(asd) == 0 | is.na(sum(aa1$coefficients)) | length(lapply(temp.matrix[c('diet.cat')], unique)[[1]]) == 1)
            next
        asd = asd[!is.na(asd) & !is.infinite(asd) & !is.nan(asd)]
        #exp(asd)/(exp(asd)+1)
        pred.extant[names(asd)] = pred.extant[names(asd)] + exp(asd)/(exp(asd)+1)
        pred.t = pred.t + summary(aa1)$coefficients[,3]
        names(pred.t) = rownames(summary(aa1)$coefficients)
        if(is.nan(sum(pred.extant)))
            break
    }
}

```


random_sample <- createDataPartition(dataX12$extant, p = 0.8, list = FALSE)
training_dataset  <- dataX12[random_sample, ]
testing_dataset <- dataX12[-random_sample, ]

for(imputedsets in 1: length(imp$imp[[1]])) {assign(paste0("dataX",imputedsets), get(paste0("dataX",imputedsets))[-1])}

##Using caret and varimp
```{r}
require(caret)
require(mice)

pred.coefs <- list()
output <- data.frame()
#for (i in 1:10) {
for (imps in 1:length(imp$imp[[1]])) {
    temp.matrix <- complete(imp, imps) [3:27]
    random_sample <- createDataPartition(temp.matrix$extant, p = 0.75, list = FALSE)
    training_dataset  <- temp.matrix[random_sample, ]
    testing_dataset <- temp.matrix[-random_sample, ]
    #fitControl <- trainControl(method = "repeatedcv",
                           #number = 10,
                           #repeats = 100)
    model <- glm(pnorm(scale(as.numeric(extant))) ~. , data = training_dataset, family="quasibinomial")
    predictions <- predict(model, testing_dataset)
    pred.coefs[[imps]] = summary(model)$coefficients
}
#}


require(plyr)
asd <- lapply(pred.coefs, as.data.frame)
ans1 = aaply(laply(asd, as.matrix), c(2, 3), mean)
ans1

sort(model$weights)

V = caret::varImp(model)

ggplot2::ggplot(V, aes(x=reorder(rownames(V),Overall), y=Overall)) +
geom_point( color="blue", size=4, alpha=0.6)+
geom_segment( aes(x=rownames(V), xend=rownames(V), y=0, yend=Overall), 
color='skyblue') +
xlab('Variable')+
ylab('Overall Importance')+
theme_light() +
coord_flip() 

data.frame( R2 = R2(predictions, as.numeric(testing_dataset$extant)),
            RMSE = RMSE(predictions, as.numeric(testing_dataset$extant)),
            MAE = MAE(predictions, as.numeric(testing_dataset$extant)))

weights123 <-  as.data.frame(model$weights)
plot(weights123$`model$weights`[weights123$`model$weights` < 0.15])
text(weights123$`model$weights`[weights123$`model$weights` < 0.15], labels = rownames(weights123)[weights123$`model$weights` < 0.15], cex = 0.7)

```

##LDA
```{r}
require(MASS)

coeffs.lda <- list()
probability.lda <- list()
for (imps in 1:length(imp$imp[[1]])) {
  temp.matrix <- complete(imp, imps) [3:27]
  a <- lda(extant ~ ., temp.matrix)
  coeffs.lda[[imps]] = a$scaling
  a1 <- lda(extant ~ ., temp.matrix, CV = TRUE)$posterior
  probability.lda[[imps]] = a1
  }

require(plyr)
coeffs.lda.all <- lapply(coeffs.lda, as.data.frame)
coeffs.lda.all1 = aaply(laply(coeffs.lda.all, as.matrix), c(2), mean)
sort(coeffs.lda.all1)

probability.lda.all <- lapply(probability.lda, as.data.frame)
#probability.lda.all1 = aaply(laply(probability.lda.all, as.matrix), c(1,2), mean)
#sort(probability.lda.all1)


m = array(dim=114, data=0)
for (i in 1:20){
 x = probability.lda.all[[i]]
 m = m + x[,2]
}
m=m/20

plot(dataX15$extant, m)

BMR <- dataX15$BMRres
BMR[BMR<0] = 0
BMR[BMR>0] = 1
BMR
fisher.test(table(BMR, dataX15$nearctic))

summary(glm(nearctic ~ BMRres, data=dataX15, family=binomial))


```