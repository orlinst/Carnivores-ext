---
title: "R Notebook"
output: html_notebook
---

#Load up data/tree/imputations
```{r}
require(phytools)
require(mulTree)

tree <- read.tree("CompletePhyCarn.nex")
data_final <- read.delim("carn-ext.txt", header=T)
rownames(data_final) <- data_final$species_name

#defining var class
data_final$extant <- as.factor(data_final$extant)
data_final$loctype <- as.factor(data_final$loctype)
data_final$activity <- as.factor(data_final$activity)
data_final$diet.cat <- as.factor(data_final$diet.cat)
data_final$Afrotropic <- as.factor(data_final$Afrotropic)
data_final$Indomalaya <- as.factor(data_final$Indomalaya)
data_final$Nearctic <- as.factor(data_final$Nearctic)
data_final$Neotropic <- as.factor(data_final$Neotropic)
data_final$Palearctic <- as.factor(data_final$Palearctic)
data_final$IUCN.status <- as.factor(data_final$IUCN.status)
data_final$soc.complexity <- as.factor(data_final$soc.complexity)

#log and scale
data_final$mass.g <- as.vector(scale(log(data_final$mass.g)))
data_final$home.range <- as.vector(scale(log(data_final$home.range)))
data_final$BMR <- as.vector(scale(log(data_final$BMR)))
data_final$density <- as.vector(scale(log(data_final$density)))
data_final$gr.size <- as.vector(scale(log(1 + data_final$gr.size))) #due to 0s
data_final$ges.days <- as.vector(scale(log(data_final$ges.days)))
data_final$interbirth.days <- as.vector(scale(log(data_final$interbirth.days)))
data_final$weaning.days <- as.vector(scale(log(data_final$weaning.days)))
data_final$longevity <- as.vector(scale(log(data_final$longevity)))
data_final$litter <- as.vector(scale(log(data_final$litter)))

#yj <- function (y) {((y+1)^0.0001 - 1) / 0.0001}
#a <- (which(!is.na(data_final$abundance)))
#a1 <- yj(which(!is.na(data_final$abundance)))
#data_final$abundance[a] <- a1[a] #transform Yeoâ€“Johnson







clean <- clean.data(data_final, tree)
tree <- clean$tree
tree1 <- clean$tree[[2]]
data <- clean$data

require(mice)
load("./imp20x100.Rdata")


for(imputedsets in 1: length(imp$imp[[1]])) {
  #extract imputed sets in separate dfs
  assign(paste0("dataX",imputedsets), complete(imp, imputedsets))
}

```


#Function - lsolm
```{r}
lsolm<-function(formula,data,binomial=FALSE,summary=TRUE)	{
	form <- formula(formula)
	if (! missing(data))	{
		y <- model.frame(form,data)[,1]
		X <- as.matrix(model.frame(form,data)[,-1])
	} else	{
		y <- model.frame(form)[,1]
		X <- as.matrix(model.frame(form)[,-1])
	}
	if (! is.matrix(X) || ncol(X) < 2)
		stop('there must be at least two predictors')
	if (binomial == FALSE)
		y <- scale(y)
	X <- scale(X)
	s <- svd(t(X))
	Z <- scale(t(s$u %*% t(s$v)))
	colnames(Z) <- colnames(X)
	if (summary == TRUE)	{
		cat('\nRows and columns in matrix:',nrow(X),'and',ncol(X),'\n')
		cat('Correlation between raw and rotated data matrices:',sprintf('%.4f',cor(as.vector(unlist(X)),as.vector(unlist(Z)))),'\n')
	}
	if (binomial == FALSE)	{
		l <- lm(y ~ .,data=data.frame(Z))
		cf <- summary(l)$coefficients
		cf <- cbind(c(NA,diag(cor(X,Z))),cf[,1],cf[,1]^2,cf[,-1])
		colnames(cf)[1:3] <- c('Cor. X','Beta coef.','Beta^2')
	} else	{
		l <- glm(y ~ .,data=data.frame(Z),family='binomial')
		cf <- summary(l)$coefficients
		cf <- cbind(c(NA,diag(cor(X,Z))),cf)
		colnames(cf)[1] <- c('Cor. X',)
	}
	if (summary == TRUE)	{
		cat('\nCoefficients:\n\n')
		b2 <- sum(as.numeric(cf[,2]))
		for (i in 1:ncol(cf))
			cf[,i] <- sprintf('% #.6g',as.numeric(cf[,i]))
		colnames(cf) <- paste0(' ',colnames(cf))
		print(cf,quote=F)
		if (binomial == FALSE)
			cat('\nMultiple R-squared (sum of squared betas):',sprintf('%.4f',summary(l)$r.squared),'\n\n')
		else
			cat('\nPseudo-R-squared:',sprintf('%.4f',1 - l$deviance / l$null.deviance),'\n\n')
	} else	{
		return(list(coefficients = cf, residuals = l$residuals, fitted.values = l$fitted.values, rotated.matrix = Z))
	}
}






```




#Function - mi.glm 
```{r}
require(tictoc)
require(phylolm)

mi.glm <- function (multree, sets, model, num, alpha=0.05, btol.v=10, boot.v=0) {
  tic("Total time")
  rand = sample.int(1000, num)
  to = length(rand)
  summaries = list()
  pvals = list()
  estimates = list()
  aic = list()
  a = 0 #counter for sig models
  b = 0
  z = matrix(ncol = (length(colnames(dataX1))*2), nrow =sets*to)
  total = sets*to
  pb <- txtProgressBar(min = 0,      # Minimum value of the progress bar
                       max = total, # Maximum value of the progress bar
                       style = 3,    # Progress bar style (also available style = 1 and style = 2)
                       width = 50,   # Progress bar width. Defaults to getOption("width")
                       char = "=")   # Character used to create the bar
  #z <- NULL
  #z <- data.frame(matrix(ncol = 10, nrow = 10))
  # gets the trees one by one, extracts the coeffs from the summary (as numeric), marks the sig p values 
  # (see print.pval fun) and prints them - progress is displayed
  rand = sample.int(1000, num)
  for (i in rand){
    for (imps in 1:sets){
      temptree <- multree[[i]]
      s1 <- phyloglm(model, get(paste0("dataX", imps)), temptree, method = c("logistic_MPLE"), btol = btol.v, boot=boot.v)
      #logistic_IG10
      b = b + 1
      k = summary(s1)$coefficients[,3]
      #print(k)
      #print(length(k))
      z[b, 1 : length(k)] = k
      
      s2 <- as.data.frame(summary(s1)$coefficients[,"p.value"]) #extract p value
      asd <- as.numeric(s2[[1]]) #save it as numeric
      
      s21 <- as.data.frame(summary(s1)$coefficients[,"Estimate"]) #export estimate
      asd1 <- as.numeric(s21[[1]])  #save as numeric
      
      s22 <- as.data.frame(summary(s1)$aic) #export aic
      asd2 <- as.numeric(s22[[1]])
    
      pvals <- rbind(pvals, asd)
      estimates <- rbind(estimates, asd1)
      aic <- rbind(aic, asd2)
      
      #s22 <- as.data.frame(summary(s1)$coefficients)
      summaries[[b]] <- s1

#      
      for(bar in 1:b) {
        setTxtProgressBar(pb, bar)}
      
      
      if(any(asd[-1]<alpha)){
        #print.pval(asd[-1]) 
        a = a+1
        cat("\n", "---------------", "\n", " N Sig models:", a, " out of", b, "", round((a/b)*100, 2), "% " ,"\n", "Models left:", (sets*to)-b, "\n") }
      
      #print(summary(s1)$coefficients[,4])
      print (summary(s1))
      #print(z)
    }
  }
  close(pb)
  cat(paste0("\n ==================== \n", " Total models: ", to, "x", sets, "=", to*sets, " (trees x imputed sets)",  "\n Significant: ", a, "\n ", "p<", alpha," in ", round((a/(to*sets))*100, 2), "% of the tested sets", "\n ==================== \n"))
  zvalues <<- colMeans((z), na.rm=T) # z or abs z?!
  #convert z values to p
  #out <- data.frame()
  
  #cat(paste0("\n P-values \n"))
  vars <- row.names(s2)
  pval <<- 2*pnorm(abs(zvalues[1:length(row.names(s2))]), lower.tail=F)
  out <- data.frame(vars, pval)
  
  #((length(row.names(dataX1)) - (length(row.names(s2)))))
  
  pvals <<- pvals
  colnames(pvals) <<- row.names(s2)
  rownames(pvals) <<- 1:nrow(pvals)
  
  estimates <<- estimates
  colnames(estimates) <<- row.names(s2)
  rownames(estimates) <<- 1:nrow(estimates)
  
  aic <- unlist(aic)
  maic <<- mean(aic)
 
  summaries <<- summaries
  
  print(out)
  print(maic)
  toc()
  out <<- out
}
```


#Function - plot.mi.glm
```{r}
plot.mi.glm <- function (pvals, estimates) {


pvals <- as.data.frame(pvals)
estimates <- as.data.frame(estimates)

pvals <- lapply(pvals, as.numeric)
estimates <- lapply(estimates, as.numeric)

pvals <- as.data.frame(pvals)
estimates <- as.data.frame(estimates)



#PLOT LOOP



for (i in 2:ncol(pvals)) {
  dev.next()
  par(mfrow=c(1,2))
  #breaks=nrow(pvals)
  #breaks=nrow(estimates)
  
  h <- hist(pvals[,i], breaks=50, plot=FALSE)
  cuts <- cut(h$breaks, c(-Inf, 0.05,1))
  plot(h, col=c("firebrick", "white")[cuts], main=paste(colnames(pvals)[i], ": Histogram of p-values \n N =", nrow(pvals), "Trees = ", nrow(pvals)/length(imp$imp[[1]]), "\n ", sum(pvals[,i] <= 0.05), "<=0.05", " \n median =", signif(median(pvals[,i]))), xlab="p-values", xaxt='n', cex.main=0.8)
  text(h$mids,h$counts,labels=h$counts, adj=c(0.5, -0.5),)
  axis(1, at = seq(0, 1, by = 0.01), las=2)
  abline(v=median(pvals[,i]),col="blue",lwd=3)
  arrows(x0 = 0.05,
         y0 = 0.001,
         x1 = 0.05,
         y1 = 100,
         code =1,
         length = 0.1,
         lwd = 4,
         col = "yellow")
  
  
  h1 <- hist(estimates[,i], breaks = 25, main=paste("Histogram of estimates \n N=", nrow(estimates), "median =", signif(median(estimates[,i]))), xlab="Estimates", col="darkmagenta", cex.main=0.8)
  text(h1$mids,h1$counts,labels=h1$counts, adj=c(0.5, -0.5))
  
}
}
```


#Calls
```{r}
#run in loop

var = as.data.frame(colnames(data_final)) #check variable names
var = var[-c(1,2, 5),1] #remove chars and extant

for (i in var) { model = paste0("extant ~", i) #add var +
                tic("Time")
                invisible(capture.output(mi.glm(tree, 20, model, 20)))
                toc()
                print(out)
                print(maic)
                plot.mi.glm (pvals, estimates)}


mi.glm(tree, 20, extant ~ mass.g, 50)

#OR
tic("Time")
invisible(capture.output(mi.glm(tree, 20, extant ~ mass.g, 2)))
toc()
out
###### mi.glm(tree, 25, extant ~ afrotropic + australasia+indomalaya+nearctic+neotropic+palearctic, 50)

plot.mi.glm (pvals, estimates)

require(mitools)

MIcombine(summaries, df.complete = 110)
summary(MIcombine(summaries))


betas <- MIextract(summaries,fun=coef)
betas1 <- do.call(rbind, betas)
vars <- MIextract(summaries, fun=vcov)
summary(MIcombine(betas,vars))


MIcombineP <- function(MIcombineRes,digits=3) {
  tStat <- MIcombineRes$coefficients/sqrt(diag(MIcombineRes$variance))
  round(2*pt(-abs(tStat),df=MIcombineRes$df),digits)
}

MIcombineP(MIcombine(summaries))


mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic

# (-) BMRres | mass.g | activity | litter | home range | terrestrial
# (+) afrotropic

#eq - n
#social (soc.complexity+gr.size + pc) - n
#reproductive (longevity + ges.days + interbirth.days + weaning.days + litter) - litter (-)
#diet (diet.cat+shannon | simpson) - n
#spatial (home.range + abundance + loctype + afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic) - hr(-), afro(+), locT (-)

```

for (i in 1:25) {colnames(summaries[[i]])[colnames(summaries[[i]]) == 'Estimate'] <- 'estimate'}
sum1 <- as.mira(summaries)





tic()
p = array(dim=32,data=0)
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(extant[b] ~ .,data=dataX1[b,c(3, 4, 6:27)], size = 1)$wts[2:33]
p[w < 0] = p [w < 0] + 1
}
p / 1000
toc()

asd <- nnet(dataX12$extant ~ .,data=dataX12[,c(3,4,6:27)], size = 1) #exclude the extant col



tic()
p = array(dim=114,data=0, dimnames=list(dataX12$species_name))
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(dataX12$extant[b] ~ .,data=dataX12[b,c(3, 4, 6:27)], size = 1)$residuals[,1]
p[names(w)] = p[names(w)]  + w
}
a <- p / 1000
toc()


tic()
p = array(dim=114,data=0, dimnames=list(dataX12$species_name))
for (i in 1:1000)   {
b = sample(1:length(extant),ceiling(length(extant) / 2))
w = nnet(dataX12$extant[b] ~ .,data=dataX12[b,c(3, 4, 6:27)], size = 1)
w2 = predict(w,dataX12[!1:114 %in% b, c(3, 4, 6:27)] )
p[rownames(w2)] = p[rownames(w2)]  + w2[,1]
}
a <- p / 1000
toc()

sort(a)


aa <- phyloglm(dataX12$extant ~ .,data=dataX12[,c(3,4,6:27)], tree[[12]])

phyloglm(extant ~ .,data=dataX1[, c(3, 4, 6:27)]







#Cross validation - 1
```{r}

var = as.data.frame(colnames(data_final))
var = var[-c(1,2, 5),1]
varX <- paste(var, collapse = "+") #full model


pred.extant <- array(dim = 114, dimnames=list(dataX12$species_name), data = 0)
pred.t <- array(dim= 33, data = 0) #dim is nr of vars
for (i in 1:10) {
  for (imps in 1:length(imp$imp[[1]])) {
  temp.matrix <- complete(imp, imps)
b = sample(1:length(temp.matrix$extant),ceiling(length(temp.matrix$extant) / 2))
#aa1 <- glm(extant ~ home.range + interbirth.days + soc.complexity, temp.matrix[b,], family="binomial")
aa1 <- glm(pnorm(scale(as.numeric(extant))) ~ varX, temp.matrix[b,], family="quasibinomial")
asd <- predict(aa1, newdata=temp.matrix[!1:nrow(data_final) %in% b,])
  if(length(asd) == 0 | is.na(sum(aa1$coefficients)))
  next
  asd = asd[!is.na(asd) & !is.infinite(asd) & !is.nan(asd)]
#exp(asd)/(exp(asd)+1)
pred.extant[names(asd)] = pred.extant[names(asd)] + exp(asd)/(exp(asd)+1)
pred.t = pred.t + summary(aa1)$coefficients[,3]
names(pred.t) = rownames(summary(aa1)$coefficients)
if(is.nan(sum(pred.extant)))
break
  }
}

pred.extant/500 #imps + iters
pred.t/200
names(pred.t) = var


cor.test(pred.extant/200, as.numeric(dataX12$extant), method = "s")


mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic


#FULL MODEL

pred.extant <- array(dim = 114, dimnames=list(dataX12$species_name), data = 0)
pred.t <- array(dim= 33, data = 0) #dim is nr of vars
for (i in 1:10) {
    for (imps in 1:length(imp$imp[[1]])) {
        temp.matrix <- complete(imp, imps)
        b = sample(1:length(temp.matrix$extant),ceiling(length(temp.matrix$extant) / 2))
        #aa1 <- glm(extant ~ home.range + interbirth.days + soc.complexity, temp.matrix[b,], family="binomial")
        aa1 <- glm(pnorm(scale(as.numeric(extant))) ~ mass.g+home.range+loctype+pc+litter+diet.cat+shannon+simpson+abundance+longevity+activity+soc.complexity+gr.size+ges.days+interbirth.days+weaning.days+eqm+BMRres+afrotropic+australasia+indomalaya+neotropic+nearctic+palearctic, temp.matrix[b,], family="quasibinomial")
        asd <- predict(aa1, newdata=temp.matrix[!1:nrow(data_final) %in% b,])
        if(length(asd) == 0 | is.na(sum(aa1$coefficients)) | length(lapply(temp.matrix[c('diet.cat')], unique)[[1]]) == 1)
            next
        asd = asd[!is.na(asd) & !is.infinite(asd) & !is.nan(asd)]
        #exp(asd)/(exp(asd)+1)
        pred.extant[names(asd)] = pred.extant[names(asd)] + exp(asd)/(exp(asd)+1)
        pred.t = pred.t + summary(aa1)$coefficients[,3]
        names(pred.t) = rownames(summary(aa1)$coefficients)
        if(is.nan(sum(pred.extant)))
            break
    }
}

```


random_sample <- createDataPartition(dataX12$extant, p = 0.8, list = FALSE)
training_dataset  <- dataX12[random_sample, ]
testing_dataset <- dataX12[-random_sample, ]

for(imputedsets in 1: length(imp$imp[[1]])) {assign(paste0("dataX",imputedsets), get(paste0("dataX",imputedsets))[-1])}

##Using caret and varimp
```{r}
require(caret)
require(mice)

pred.coefs <- list()
output <- data.frame()
#for (i in 1:10) {
for (imps in 1:length(imp$imp[[1]])) {
    temp.matrix <- complete(imp, imps) [3:27]
    random_sample <- createDataPartition(temp.matrix$extant, p = 0.75, list = FALSE)
    training_dataset  <- temp.matrix[random_sample, ]
    testing_dataset <- temp.matrix[-random_sample, ]
    #fitControl <- trainControl(method = "repeatedcv",
                           #number = 10,
                           #repeats = 100)
    model <- glm(pnorm(scale(as.numeric(extant))) ~. , data = training_dataset, family="quasibinomial")
    predictions <- predict(model, testing_dataset)
    pred.coefs[[imps]] = summary(model)$coefficients
}
#}


require(plyr)
asd <- lapply(pred.coefs, as.data.frame)
ans1 = aaply(laply(asd, as.matrix), c(2, 3), mean)
ans1

sort(model$weights)

V = caret::varImp(model)

ggplot2::ggplot(V, aes(x=reorder(rownames(V),Overall), y=Overall)) +
geom_point( color="blue", size=4, alpha=0.6)+
geom_segment( aes(x=rownames(V), xend=rownames(V), y=0, yend=Overall), 
color='skyblue') +
xlab('Variable')+
ylab('Overall Importance')+
theme_light() +
coord_flip() 

data.frame( R2 = R2(predictions, as.numeric(testing_dataset$extant)),
            RMSE = RMSE(predictions, as.numeric(testing_dataset$extant)),
            MAE = MAE(predictions, as.numeric(testing_dataset$extant)))

weights123 <-  as.data.frame(model$weights)
plot(weights123$`model$weights`[weights123$`model$weights` < 0.15])
text(weights123$`model$weights`[weights123$`model$weights` < 0.15], labels = rownames(weights123)[weights123$`model$weights` < 0.15], cex = 0.7)

```

##LDA
```{r}
require(MASS)

coeffs.lda <- list()
probability.lda <- list()
for (imps in 1:length(imp$imp[[1]])) {
  temp.matrix <- complete(imp, imps) [3:27]
  a <- lda(extant ~ ., temp.matrix)
  coeffs.lda[[imps]] = a$scaling
  a1 <- lda(extant ~ ., temp.matrix, CV = TRUE)$posterior
  probability.lda[[imps]] = a1
  }

require(plyr)
coeffs.lda.all <- lapply(coeffs.lda, as.data.frame)
coeffs.lda.all1 = aaply(laply(coeffs.lda.all, as.matrix), c(2), median)
sort(coeffs.lda.all1)

probability.lda.all <- lapply(probability.lda, as.data.frame)
#probability.lda.all1 = aaply(laply(probability.lda.all, as.matrix), c(1,2), mean)
#sort(probability.lda.all1)


m = array(dim=114, data=0)
for (i in 1:20){
 x = probability.lda.all[[i]]
 m = m + x[,2]
}
m=m/20

plot(dataX15$extant, m)

BMR <- dataX15$BMRres
BMR[BMR<0] = 0
BMR[BMR>0] = 1
BMR
fisher.test(table(BMR, dataX15$nearctic))

summary(glm(nearctic ~ BMRres, data=dataX15, family=binomial))


```


```{r}
#for each cat var and genus and family

namedummievar <- table(nrow, df[nrow, varcol])
m = matrix(unlist(namedv), nrow(namedv), ncol(namedv))

tempx = cbind(x, namedv)

for (i in 1:20) {}
loctype <- table(1:114, data_final[1:114, "loctype"])
m = matrix(unlist(loctype), nrow(loctype), ncol(loctype))

tempx = cbind(x, namedv)


get genus names:
data_final$genus <- sapply(strsplit(data_final$species_name,"_"), `[`, 1)  
get family
w <- match(data_final$species, IUCN.Carnivora.taxonomy$scientificName)
data_final$family <- IUCN.Carnivora.taxonomy$familyName[w]


loctype
diet.cat
activity









m1 <- match(data_final2023$species_name, data_final$species_name)
data_final2023$activity <- data_final$activity[m1]

write.table(data_final2023, "data_final2023.txt", sep = "\t", row.names = FALSE)




```


#lsolm calls
```{r}

d2 = data.matrix(dataX1[,c(5:10,13,14,17:27)])
p = matrix(NA,ncol(d2)+31,20)
s = matrix(NA,ncol(d2)+31,20)
d = list()

g = sample(1:1000, 100, replace=F)

#phylop = matrix(NA,ncol(d2)+31,20)
phylop=array(dim=c(ncol(d2)+31,20, 1000))
phylopmulti = matrix(NA,1000,1000)

for (j in 1:20) {
    n = data.matrix(get(paste0("dataX", j))[,c(11)])
    loctype <- table(1:128, n)
    m1 = matrix(unlist(loctype), nrow(loctype), ncol(loctype), dimnames=list(1:128, colnames(loctype)))
    
    n = data.matrix(get(paste0("dataX", j))[,c(12)])
    diet.cat <- table(1:128, n)
    m2 = matrix(unlist(diet.cat), nrow(diet.cat), ncol(diet.cat), dimnames=list(1:128, colnames(diet.cat)))
    
    n = data.matrix(get(paste0("dataX", j))[,c(15)])
    activity <- table(1:128, n)
    m3 = matrix(unlist(activity), nrow(activity), ncol(activity), dimnames=list(1:128, colnames(activity)))
    
    n = data.matrix(get(paste0("dataX", j))[,c(16)])
    soc <- table(1:128, n)
    m4 = matrix(unlist(soc), nrow(soc), ncol(soc), dimnames=list(1:128, colnames(soc)))
    
    d[[j]] = data.matrix(get(paste0("dataX", j))[,c(5:10,13,14,17:27)])
    tempx = cbind(d[[j]], m1, m2, m3, m4)
    d0 = data.matrix(dataX1)
    m = lsolm(d0[,3] ~ ., data = data.frame(tempx),summary=F)$rotated.matrix
    rownames(m) <- data_final$species_name
    cat(colnames(d)[i],'\n')
  #for (i in 1:ncol(m)) {
    #add var numbers
  for (i in 1:40) {
     
    p[i,j] <- summary(glm(as.factor(d0[,3]) ~ m[,i],family='binomial'))$coefficients[2,4]
    s[i,j] <- summary(glm(as.factor(d0[,3]) ~ m[,i],family='binomial'))$coefficients[2,1]
    stdevs <- which(rowSds(t(m))!=0)
    w = as.array(m[,i])
    dimnames(w) <- list(data_final$species_name)
  
    temp = cbind(m[,i], as.integer(data_final$extant)) #)-1)
    colnames(temp) = c("whateva", "extant")
    rownames(temp) = rownames(m)
  for (t in g) { 
    phylop[i,j,t] <- summary(phyloglm(extant ~ ., data = data.frame(temp), btol = 30, method="logistic_IG10", phy = tree[[t]]))$coefficients[2,"p.value"]
    #phylop[1:19,j] <- summary(phyloglm(V41 ~ ., data = data.frame(cbind(m, as.integer(data_final$extant)-1)), method="logistic_MPLE", phy = tree[[1]]))$coefficients[2:20,"p.value"]
    }
    }
}

medians <- array()
for(i in 1:40) {
medians[i] <- median(phylop[i,,], na.rm = T)
}

options("scipen"=100, "digits"=4)
phylopmulti[32, ]
median(unlist(phylopmulti[32, ]), na.rm=TRUE)

cbind(rowMedians(p[1:40,]), colnames(m))

}}

aaa <- sort(rowMedians(phylop))
p.adjust holm
